<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title>A Whirlwind Tour of Computer Science</title>

<meta charset="utf-8"/>

<meta name=viewport content="width=device-width, initial-scale=1">
<link rel="icon" href="https://emojipedia-us.s3.dualstack.us-west-1.amazonaws.com/thumbs/120/apple/237/mountain_26f0.png">

<link href="https://fonts.googleapis.com/css?family=DM+Sans" rel="stylesheet">

<link rel="stylesheet" href="https://latex.now.sh/style.min.css" />

</head>

<body>

  <div class="container" id="navbar" style="margin-top: 5.5rem;">
    <div class="col-md-offset-1 col-md-9">
    <div class="row">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <div class="icon-bar">
      <a class="active" href="../index.html">home</a>
    </div>
  </div>
  </div>
  </div>

<div class="container" id="content">
  <div class="col-md-offset-1 col-md-9">
  <div class="row">
      <div id="name">
      	<h1>A Whirlwind Tour of Computer Science</h1>
      </div>
  </div>
  </div>
 </div>

 <div class="container" id="maintext" style="margin-top: 5.5rem;">
   <div class="col-md-offset-1 col-md-9">
   <div class="row">
     <p>
      I am very lucky to do my research somewhere between a compiler group and a machine learning group.
      </p>
      <p>
      Since most of them are physicists, mathematicians, or engineers, many of the machine learning researchers I come across are perplexed by the idea of a whole degree about programming, to which I eagerly quote Michael Fellows:
      </p>

        <blockquote>
          <br>
        <p>
          Computer science is no more about computers than astronomy is about telescopes, biology is about microscopes, or chemistry is about beakers and test tubes.
        </p>
        </blockquote>


      <p>
      Despite how fun this quote is, itâ€™s often quite hard to pinpoint what really separates computer science from anything else. One could argue we are closer to discrete mathematicians, but doesnâ€™t that just make us <i>bad</i> mathematicians?
      </p>

      <div class="col-md-offset-1" style="margin-top:2em; margin-bottom:2em;">
        <blockquote class="twitter-tweet"><p lang="en" dir="ltr">Date: Iâ€™m a computer scientist<br>Me (trying to impress him): Iâ€™m hopeless at math too</p>&mdash; Loch Nessa MonsterðŸŒ¸ (@pasiphae_goals) <a href="https://twitter.com/pasiphae_goals/status/1092123079298478080?ref_src=twsrc%5Etfw">February 3, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
      </div>
      <p>
      The answer that Iâ€™ve settled on is that there is something unexplainably <b>fun</b> about studying computer science. And isnâ€™t that it's all about anyway?
      </p>

      <p>
      So, I present my list of resources; a whirlwind tour of the wonders of computer science.
      </p>


      <h3>
        Full Courses
      </h3>

      <br>

      <ul>
        <li><b><a href="https://computationstructures.org/index.html">Computation Structures</a></b> <br>
            If I had to recommend one tour of computer science, it would be this one.
            It covers everything from basic circuit design to virtual memory and parallel programming,
            and yet somehow still manages to skirt the line between computer engineering and theoretical
            computer science.
        </li>
        <br>

        <li><b><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/">Structure and Interpretation of Computer Programs</a></b> <br>
            An undisputable classic. It comes with lecture videos, a book, exercises, and more!
            You might bemoan the use of Scheme, to which I respond with a pointer to the above quote.
        </li>

        <br>

        <li><b><a href="https://see.stanford.edu/Course/CS107">Programming Paradigms (CS107)</a></b> <br>
          This heavily overlaps with Computation Structures (see above) but is perhaps a little more applied,
          though equal in beauty.
        </li>

      </ul>


      <h3>
        Books
      </h3>

      <br>

      <ul>
        <li><b><a href="https://en.wikipedia.org/wiki/GÃ¶del,_Escher,_Bach">GÃ¶del Escher Bach: An Eternal Golden Braid</a></b> <br>
          To me, GEB is in some ways the bedtime story version of Structure and Interpretation of Computer Programs.
          Every chapter of this book will delight and surprise you.
        </li>

        <br>

        <li><b><a href="http://dev.stephendiehl.com/fun/WYAH.pdf">Write You A Haskell</a></b> <br>
          Have you ever wondered how to make your own programming language? It turns out that the process of doing
          so requires a deep understanding of some of the hardest and most intricate problems in computer science.
          Compiler technology lends itself well to the use of neatly composed trees, graphs, search algorithms, and more.

      </ul>

      <h3>
        Projects to be aware of
      </h3>

      <br>

      <p>
      I have a grand plan to write a blog post about all of these, but for now I will settle for a list:
      </p>
      <ul>
        <li><b><a href="https://tvm.apache.org">TVM</a></b> <br>
          TVM is a high performance code generator specifically designed for machine learning workloads.
          Basically, if you need something slightly unconventional to run fast, TVM is your friend.
          It plugs in neatly to other frameworks (via ONNX, or TorchScript IR) so you can mostly use it
          directly from your deep learning framework of choice.
        </li>

        <br>

        <li><b><a href="https://jax.readthedocs.io/en/latest/">JAX</a></b> <br>
          JAX is numpy + autograd + XLA, which means you can write your code in almost raw Python,
          and it will be both differentiable and fast on most hardware.
        </li>

        <br>

        <li><b><a href="https://pytorch.org/docs/stable/jit.html">TorchScript</a></b> <br>
          TorchScript is orthogonal to JAX; it acts as an IR that can lower from PyTorch to
          whatever low level code you need generated (e.g. CUDA, C++). This makes it really
          easy to optimise and deploy your models across various devices.
        </li>

        <br>

        <li><b><a href="https://mlir.llvm.org">MLIR</a></b> <br>
          Really the problem that these tools are trying to address is the complexity of the
          lowering step from high level Python descriptions to optimised, low level machine code.
          Each of the steps of the lowering process can come with domain specific information
          that might aid optimisation. MLIR is compiler infrastructure built with this in mind;
          it's quite young, but very exciting.
        </li>
      </ul>

   </div>
   </div>
  </div>



</body> </html>
